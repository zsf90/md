{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"\u9996\u9875"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"about/","text":"","title":"About"},{"location":"event_group/","text":"\u4e8b\u4ef6\u7ec4 \u521b\u5efa\u4e8b\u4ef6\u7ec4 xEventGroupCreate() #include \u201cFreeRTOS.h\u201d #include \u201cevent_groups.h\u201d EventGroupHandle_t xEventGroupCreate( void ); \u4e8b\u4ef6\u5220\u9664\u51fd\u6570 vEventGroupDelete() \u51fd\u6570\u5b9a\u4e49 void vEventGroupDelete( EventGroupHandle_t xEventGroup ) { EventGroup_t * pxEventBits = xEventGroup; const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits ); vTaskSuspendAll(); { traceEVENT_GROUP_DELETE( xEventGroup ); while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 ) { /* Unblock the task, returning 0 as the event list is being deleted * and cannot therefore have any bits set. */ configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) ); vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET ); } #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) { /* The event group can only have been allocated dynamically - free * it again. */ vPortFree( pxEventBits ); } #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) { /* The event group could have been allocated statically or * dynamically, so check before attempting to free the memory. */ if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE ) { vPortFree( pxEventBits ); } else { mtCOVERAGE_TEST_MARKER(); } } #endif /* configSUPPORT_DYNAMIC_ALLOCATION */ } ( void ) xTaskResumeAll(); } \u4e8b\u4ef6\u7ec4\u7f6e\u4f4d\u51fd\u6570 xEventGroupSetBitsFromISR() \u8be5\u51fd\u6570\u662f\u4e2d\u65ad\u4e13\u7528\u7684\uff0c\u529f\u80fd\u548cxEventGroupSetBits\u7c7b\u4f3c\u3002 \u4e8b\u4ef6\u7b49\u5f85 EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, /* \u4e8b\u4ef6\u6807\u5fd7\u7ec4\u53e5\u67c4 */ const EventBits_t uxBitsToWaitFor, /* \u7b49\u5f85\u88ab\u8bbe\u7f6e\u7684\u4e8b\u4ef6\u6807\u5fd7\u4f4d */ const BaseType_t xClearOnExit, /* \u9009\u62e9\u662f\u5426\u6e05\u96f6\u88ab\u7f6e\u4f4d\u7684\u4e8b\u4ef6\u6807\u5fd7\u4f4d */ const BaseType_t xWaitForAllBits, /* \u9009\u62e9\u662f\u5426\u7b49\u5f85\u6240\u6709\u6807\u5fd7\u4f4d\u90fd\u88ab\u8bbe\u7f6e */ TickType_t xTicksToWait /* \u8bbe\u7f6e\u7b49\u5f85\u65f6\u95f4 */ ); \u4f8b\u5b50 - \u5728\u4e2d\u65ad\u4e2d\u7f6e\u4f4d\u4e8b\u4ef6\u7ec4 // \u521b\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u7ec4handle\u53d8\u91cf EventGroupHandle_t event_group_1; #define BIT_0 (1<<0) #define BIT_4 (1<<4) /* * \u5916\u90e8\u4e2d\u65ad 0,1 \u5904\u7406\u51fd\u6570 */ void EXTI0_1_IRQHandler(void) { if(RESET != exti_interrupt_flag_get(BOARD_BTN_EXTI_LINE)) { BaseType_t xResult; BaseType_t xHigherPriorityTaskWoken = pdFALSE; xResult = xEventGroupSetBitsFromISR(event_group_1, BIT_0, &xHigherPriorityTaskWoken); if(xResult != pdFAIL) { portYIELD_FROM_ISR(xHigherPriorityTaskWoken); } exti_interrupt_flag_clear(BOARD_BTN_EXTI_LINE); // \u6e05\u9664\u4e2d\u65ad\u6807\u5fd7 } } // \u4efb\u52a1\u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u53d1\u751f void led_task(void *pvParameters) { EventBits_t uxBits; const TickType_t xTicksToWait = 100; while(1) { uxBits = xEventGroupWaitBits(event_group_1, BIT_0, pdTRUE, pdTRUE, xTicksToWait); if(uxBits & BIT_0) { gd_eval_led_toggle(LED2); } } }","title":"\u4e8b\u4ef6"},{"location":"event_group/#_1","text":"","title":"\u4e8b\u4ef6\u7ec4"},{"location":"event_group/#_2","text":"xEventGroupCreate() #include \u201cFreeRTOS.h\u201d #include \u201cevent_groups.h\u201d EventGroupHandle_t xEventGroupCreate( void );","title":"\u521b\u5efa\u4e8b\u4ef6\u7ec4"},{"location":"event_group/#veventgroupdelete","text":"\u51fd\u6570\u5b9a\u4e49 void vEventGroupDelete( EventGroupHandle_t xEventGroup ) { EventGroup_t * pxEventBits = xEventGroup; const List_t * pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits ); vTaskSuspendAll(); { traceEVENT_GROUP_DELETE( xEventGroup ); while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 ) { /* Unblock the task, returning 0 as the event list is being deleted * and cannot therefore have any bits set. */ configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) ); vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET ); } #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) ) { /* The event group can only have been allocated dynamically - free * it again. */ vPortFree( pxEventBits ); } #elif ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) { /* The event group could have been allocated statically or * dynamically, so check before attempting to free the memory. */ if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE ) { vPortFree( pxEventBits ); } else { mtCOVERAGE_TEST_MARKER(); } } #endif /* configSUPPORT_DYNAMIC_ALLOCATION */ } ( void ) xTaskResumeAll(); }","title":"\u4e8b\u4ef6\u5220\u9664\u51fd\u6570 vEventGroupDelete()"},{"location":"event_group/#xeventgroupsetbitsfromisr","text":"\u8be5\u51fd\u6570\u662f\u4e2d\u65ad\u4e13\u7528\u7684\uff0c\u529f\u80fd\u548cxEventGroupSetBits\u7c7b\u4f3c\u3002 \u4e8b\u4ef6\u7b49\u5f85 EventBits_t xEventGroupWaitBits( const EventGroupHandle_t xEventGroup, /* \u4e8b\u4ef6\u6807\u5fd7\u7ec4\u53e5\u67c4 */ const EventBits_t uxBitsToWaitFor, /* \u7b49\u5f85\u88ab\u8bbe\u7f6e\u7684\u4e8b\u4ef6\u6807\u5fd7\u4f4d */ const BaseType_t xClearOnExit, /* \u9009\u62e9\u662f\u5426\u6e05\u96f6\u88ab\u7f6e\u4f4d\u7684\u4e8b\u4ef6\u6807\u5fd7\u4f4d */ const BaseType_t xWaitForAllBits, /* \u9009\u62e9\u662f\u5426\u7b49\u5f85\u6240\u6709\u6807\u5fd7\u4f4d\u90fd\u88ab\u8bbe\u7f6e */ TickType_t xTicksToWait /* \u8bbe\u7f6e\u7b49\u5f85\u65f6\u95f4 */ );","title":"\u4e8b\u4ef6\u7ec4\u7f6e\u4f4d\u51fd\u6570 xEventGroupSetBitsFromISR()"},{"location":"event_group/#-","text":"// \u521b\u5efa\u4e00\u4e2a\u4e8b\u4ef6\u7ec4handle\u53d8\u91cf EventGroupHandle_t event_group_1; #define BIT_0 (1<<0) #define BIT_4 (1<<4) /* * \u5916\u90e8\u4e2d\u65ad 0,1 \u5904\u7406\u51fd\u6570 */ void EXTI0_1_IRQHandler(void) { if(RESET != exti_interrupt_flag_get(BOARD_BTN_EXTI_LINE)) { BaseType_t xResult; BaseType_t xHigherPriorityTaskWoken = pdFALSE; xResult = xEventGroupSetBitsFromISR(event_group_1, BIT_0, &xHigherPriorityTaskWoken); if(xResult != pdFAIL) { portYIELD_FROM_ISR(xHigherPriorityTaskWoken); } exti_interrupt_flag_clear(BOARD_BTN_EXTI_LINE); // \u6e05\u9664\u4e2d\u65ad\u6807\u5fd7 } } // \u4efb\u52a1\u963b\u585e\u7b49\u5f85\u4e8b\u4ef6\u53d1\u751f void led_task(void *pvParameters) { EventBits_t uxBits; const TickType_t xTicksToWait = 100; while(1) { uxBits = xEventGroupWaitBits(event_group_1, BIT_0, pdTRUE, pdTRUE, xTicksToWait); if(uxBits & BIT_0) { gd_eval_led_toggle(LED2); } } }","title":"\u4f8b\u5b50 - \u5728\u4e2d\u65ad\u4e2d\u7f6e\u4f4d\u4e8b\u4ef6\u7ec4"},{"location":"semaphore/","text":"\u4fe1\u53f7\u91cf \u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf \u4e8c\u503c\u4fe1\u53f7\u91cf\u5de5\u4f5c\u793a\u610f\u56fe\uff1a xSemaphoreGive \u51fd\u6570\u539f\u578b\uff1a BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); xSemaphore \u521b\u5efa\u7684\u4fe1\u53f7\u91cf\u53e5\u67c4 BaseType_t \u8fd4\u56de\u7c7b\u578b\uff1apdPASS\uff08Give\u6210\u529f\uff09\uff0cpdFAIL\uff08Give\u5931\u8d25\uff09 \u6309\u952e\u6d88\u6296 \u8be5\u4f8b\u5b50\u4f7f\u7528 \u4e8c\u503c\u4fe1\u53f7\u91cf \u5b9e\u73b0\u6309\u952e\u6d88\u6296\u3002 /* * \u5916\u90e8\u4e2d\u65ad 0,1 \u5904\u7406\u51fd\u6570 */ void EXTI0_1_IRQHandler(void) { BaseType_t result; BaseType_t xHigherPriorityTaskWoken = pdFALSE; if(RESET != exti_interrupt_flag_get(BOARD_BTN_EXTI_LINE)) { xSemaphoreGiveFromISR(semaphore_1, &xHigherPriorityTaskWoken); if (result == pdTRUE) { // Give \u6210\u529f portYIELD_FROM_ISR(xHigherPriorityTaskWoken); } exti_interrupt_flag_clear(BOARD_BTN_EXTI_LINE); // \u6e05\u9664\u4e2d\u65ad\u6807\u5fd7 } } void app_main(void) { semaphore_1 = xSemaphoreCreateBinary(); // \u521b\u5efa\u4fe1\u53f7\u91cf xTaskCreate(key_scan_task, \"key_scan_task\", 128, NULL, 1, NULL); xTaskCreate(led_task, \"led_task\", 128, NULL, 1, NULL); vTaskStartScheduler(); // \u542f\u52a8\u8c03\u5ea6\u5668 } void led_task(void *pvParameters) { while(1) { xSemaphoreTake(semaphore_1, portMAX_DELAY); vTaskDelay(10); if(gpio_input_bit_get(BOARD_BTN_PORT, BOARD_BTN_PIN) == RESET) { gd_eval_led_toggle(LED1); } } } // led_task","title":"\u4fe1\u53f7\u91cf"},{"location":"semaphore/#_1","text":"","title":"\u4fe1\u53f7\u91cf"},{"location":"semaphore/#_2","text":"\u4e8c\u503c\u4fe1\u53f7\u91cf\u5de5\u4f5c\u793a\u610f\u56fe\uff1a","title":"\u4e8c\u8fdb\u5236\u4fe1\u53f7\u91cf"},{"location":"semaphore/#xsemaphoregive","text":"\u51fd\u6570\u539f\u578b\uff1a BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); xSemaphore \u521b\u5efa\u7684\u4fe1\u53f7\u91cf\u53e5\u67c4 BaseType_t \u8fd4\u56de\u7c7b\u578b\uff1apdPASS\uff08Give\u6210\u529f\uff09\uff0cpdFAIL\uff08Give\u5931\u8d25\uff09","title":"xSemaphoreGive"},{"location":"semaphore/#_3","text":"\u8be5\u4f8b\u5b50\u4f7f\u7528 \u4e8c\u503c\u4fe1\u53f7\u91cf \u5b9e\u73b0\u6309\u952e\u6d88\u6296\u3002 /* * \u5916\u90e8\u4e2d\u65ad 0,1 \u5904\u7406\u51fd\u6570 */ void EXTI0_1_IRQHandler(void) { BaseType_t result; BaseType_t xHigherPriorityTaskWoken = pdFALSE; if(RESET != exti_interrupt_flag_get(BOARD_BTN_EXTI_LINE)) { xSemaphoreGiveFromISR(semaphore_1, &xHigherPriorityTaskWoken); if (result == pdTRUE) { // Give \u6210\u529f portYIELD_FROM_ISR(xHigherPriorityTaskWoken); } exti_interrupt_flag_clear(BOARD_BTN_EXTI_LINE); // \u6e05\u9664\u4e2d\u65ad\u6807\u5fd7 } } void app_main(void) { semaphore_1 = xSemaphoreCreateBinary(); // \u521b\u5efa\u4fe1\u53f7\u91cf xTaskCreate(key_scan_task, \"key_scan_task\", 128, NULL, 1, NULL); xTaskCreate(led_task, \"led_task\", 128, NULL, 1, NULL); vTaskStartScheduler(); // \u542f\u52a8\u8c03\u5ea6\u5668 } void led_task(void *pvParameters) { while(1) { xSemaphoreTake(semaphore_1, portMAX_DELAY); vTaskDelay(10); if(gpio_input_bit_get(BOARD_BTN_PORT, BOARD_BTN_PIN) == RESET) { gd_eval_led_toggle(LED1); } } } // led_task","title":"\u6309\u952e\u6d88\u6296"},{"location":"task/","text":"\u4efb\u52a1 \u542f\u52a8\u8c03\u5ea6\u5668 vTaskStartScheduler(); // \u542f\u52a8\u8c03\u5ea6\u5668 xTaskCreate - \u521b\u5efa\u4efb\u52a1 \u51fd\u6570\u539f\u578b\uff1a BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) \u8fd4\u56de\u7c7b\u578b \u8fd4\u56de\u7c7b\u578b\uff1a BaseType_t ->long \u53c2\u6570 TaskFunction_t pxTaskCode \u4efb\u52a1\u51fd\u6570 const char * const pcName \u4efb\u52a1\u540d\u79f0 const configSTACK_DEPTH_TYPE usStackDepth \u5806\u6808\u5927\u5c0f\uff0c\u5355\u4f4d\uff08\u5b57\uff09 void * const pvParameters \u4efb\u52a1\u53c2\u6570 UBaseType_t uxPriority , \u4efb\u52a1\u4f18\u5148\u7ea7 TaskHandle_t * const pxCreatedTask \u4efb\u52a1\u53e5\u67c4","title":"\u4efb\u52a1"},{"location":"task/#_1","text":"","title":"\u4efb\u52a1"},{"location":"task/#_2","text":"vTaskStartScheduler(); // \u542f\u52a8\u8c03\u5ea6\u5668","title":"\u542f\u52a8\u8c03\u5ea6\u5668"},{"location":"task/#xtaskcreate-","text":"\u51fd\u6570\u539f\u578b\uff1a BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask )","title":"xTaskCreate - \u521b\u5efa\u4efb\u52a1"},{"location":"task/#_3","text":"\u8fd4\u56de\u7c7b\u578b\uff1a BaseType_t ->long \u53c2\u6570 TaskFunction_t pxTaskCode \u4efb\u52a1\u51fd\u6570 const char * const pcName \u4efb\u52a1\u540d\u79f0 const configSTACK_DEPTH_TYPE usStackDepth \u5806\u6808\u5927\u5c0f\uff0c\u5355\u4f4d\uff08\u5b57\uff09 void * const pvParameters \u4efb\u52a1\u53c2\u6570 UBaseType_t uxPriority , \u4efb\u52a1\u4f18\u5148\u7ea7 TaskHandle_t * const pxCreatedTask \u4efb\u52a1\u53e5\u67c4","title":"\u8fd4\u56de\u7c7b\u578b"}]}