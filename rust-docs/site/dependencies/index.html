<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh_CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <meta name="author" content="信念D力量">
  <link rel="canonical" href="https://www.zsf90.com/dependencies/">
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>依赖 - Rust 编程文档 - 信念D力量</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700" />

  <link rel="stylesheet" href="../css/theme.css" />
  <link rel="stylesheet" href="../css/theme_extra.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
  <link href="../css/zsf90.css" rel="stylesheet" />
  
  <script>
    // Current page data
    var mkdocs_page_name = "\u4f9d\u8d56";
    var mkdocs_page_input_path = "dependencies.md";
    var mkdocs_page_url = "/dependencies/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/rust.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> Rust 编程文档 - 信念D力量</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="..">首页</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">基础</span></p>
                <ul class="current">
                    <li class="toctree-l1"><a class="reference internal" href="../data-type/">数据类型</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../struct/">结构体</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../Trait/">Trait</a>
                    </li>
                    <li class="toctree-l1 current"><a class="reference internal current" href="./">依赖</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#cratesio">从 crates.io 引入依赖包</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#_1">^ 指定版本</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_2">~ 指定版本</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_3">* 通配符</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_4">比较符</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#_5">从其它注册服务引入依赖包</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#git">引入 git 仓库作为依赖包</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_6">通过路径引入本地依赖包</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_7">多引用方式混合</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#_8">根据平台引入依赖</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#target">自定义 target 引入</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#dev-dependencies">[dev-dependencies]</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#build-dependencies">[build-dependencies]</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#features">选择 features</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cargotoml">在 Cargo.toml 中重命名依赖</a>
    </li>
    </ul>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">std标准库</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../std-ops/">ops 模块</a>
                    </li>
                </ul>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../lib-list/">库列表</a>
                    </li>
                </ul>
                <p class="caption"><span class="caption-text">关于</span></p>
                <ul>
                    <li class="toctree-l1"><a class="reference internal" href="../about/">About</a>
                    </li>
                    <li class="toctree-l1"><a class="reference internal" href="../license/">License</a>
                    </li>
                </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">Rust 编程文档 - 信念D力量</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
        
          <li>基础 &raquo;</li>
        
      
    
    <li>依赖</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  
  <hr/>
</div>

          <div role="main">
            <div class="section">
              
                <h2 id="rust-cargotoml-crate">Rust 中通过在 Cargo.toml 中添加依赖来使用各种的 crate</h2>
<h3 id="cratesio">从 crates.io 引入依赖包</h3>
<p>默认设置下，Cargo 就从 crates.io 上下载依赖包，只需要一个包名和版本号即可：</p>
<pre><code class="language-toml">[dependencies]
time = &quot;0.1.12&quot;
</code></pre>
<p>字符串 <code>"0.1.12"</code> 是一个 <a href="https://semver.org/">semver</a> 格式的版本号，符合 <code>"x.y.z"</code> 的形式，其中 <code>x</code> 被称为主版本 <code>major</code>, <code>y</code> 被称为小版本 <code>minor</code> ，而 <code>z</code> 被称为补丁 <code>patch</code>，可以看出从左到右，版本的影响范围逐步降低，补丁的更新是无关痛痒的，并不会造成 <code>API</code> 的兼容性被破坏。</p>
<p><code>"0.1.12"</code> 中并没有任何额外的符号，在版本语义上，它跟使用了 <code>^</code> 的 <code>"^0.1.12"</code> 是相同的，都是指定非常具体的版本进行引入。</p>
<p>但是 <code>^</code> 能做的更多。</p>
<blockquote>
<p>npm 使用的就是 <code>semver</code> 版本号，从 <code>JavaScript</code> 过来的同学应该非常熟悉。</p>
</blockquote>
<h4 id="_1"><a href="https://course.rs/cargo/reference/specify-deps.html#-%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC"><code>^</code> 指定版本</a></h4>
<p>与之前的 <code>"0.1.12"</code> 不同， <code>^</code> 可以指定一个版本号范围， <strong>然后会使用该范围内的最大版本号来引用对应的包</strong> 。</p>
<p>只要新的版本号没有修改最左边的非零数字，那该版本号就在允许的版本号范围中。例如 <code>"^0.1.12"</code> 最左边的非零数字是 <code>1</code>，因此，只要新的版本号是 <code>"0.1.z"</code> 就可以落在范围内，而 <code>0.2.0</code> 显然就没有落在范围内，因此通过 <code>"^0.1.12"</code> 引入的依赖包是无法被升级到 <code>0.2.0</code> 版本的。</p>
<p>同理，若是 <code>"^1.0"</code>，则 <code>1.1</code> 在范围中，<code>2.0</code> 则不在。 大家思考下，<code>"^0.0.1"</code> 与哪些版本兼容？答案是：无，因为它最左边的数字是 <code>1</code> ，而该数字已经退无可退，我们又不能修改 <code>1</code>，因此没有版本落在范围中。</p>
<pre><code class="language-shell">
^1.2.3  :=  &gt;=1.2.3, &lt;2.0.0
^1.2    :=  &gt;=1.2.0, &lt;2.0.0
^1      :=  &gt;=1.0.0, &lt;2.0.0
^0.2.3  :=  &gt;=0.2.3, &lt;0.3.0
^0.2    :=  &gt;=0.2.0, &lt;0.3.0
^0.0.3  :=  &gt;=0.0.3, &lt;0.0.4
^0.0    :=  &gt;=0.0.0, &lt;0.1.0
^0      :=  &gt;=0.0.0, &lt;1.0.0
</code></pre>
<p>以上是更多的例子， <strong>事实上，这个规则跟 <code>SemVer</code> 还有所不同</strong> ，因为对于 <code>SemVer</code> 而言，<code>0.x.y</code> 的版本是没有其它版本与其兼容的，而对于 Rust，只要版本号 <code>0.x.y</code> 满足 ： <code>z&gt;=y</code> 且 <code>x&gt;0</code> 的条件，那它就能更新到 <code>0.x.z</code> 版本。</p>
<h4 id="_2"><a href="https://course.rs/cargo/reference/specify-deps.html#-%E6%8C%87%E5%AE%9A%E7%89%88%E6%9C%AC-1"><code>~</code> 指定版本</a></h4>
<p><code>~</code> 指定了最小化版本 :</p>
<pre><code class="language-shell">~1.2.3  := &gt;=1.2.3, &lt;1.3.0
~1.2    := &gt;=1.2.0, &lt;1.3.0
~1      := &gt;=1.0.0, &lt;2.0.0
</code></pre>
<h4 id="_3"><a href="https://course.rs/cargo/reference/specify-deps.html#-%E9%80%9A%E9%85%8D%E7%AC%A6"><code>*</code> 通配符</a></h4>
<p>这种方式允许将 <code>*</code> 所在的位置替换成任何数字:</p>
<pre><code class="language-shell">*     := &gt;=0.0.0
1.*   := &gt;=1.0.0, &lt;2.0.0
1.2.* := &gt;=1.2.0, &lt;1.3.0
</code></pre>
<p>不过 <code>crates.io</code> 并不允许我们只使用孤零零一个 <code>*</code> 来指定版本号 : <code>*</code>。</p>
<h4 id="_4"><a href="https://course.rs/cargo/reference/specify-deps.html#%E6%AF%94%E8%BE%83%E7%AC%A6">比较符</a></h4>
<p>可以使用比较符的方式来指定一个版本号范围或一个精确的版本号:</p>
<pre><code class="language-shell">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<p>同时还能使用比较符进行组合，并通过逗号分隔：</p>
<pre><code class="language-shell">&gt;= 1.2, &lt; 1.5
</code></pre>
<p>需要注意，以上的版本号规则仅仅针对 <code>crate.io</code> 和基于它搭建的注册服务(例如科大服务源) ，其它注册服务(例如 GitHub )有自己相应的规则。</p>
<h3 id="_5"><a href="https://course.rs/cargo/reference/specify-deps.html#%E4%BB%8E%E5%85%B6%E5%AE%83%E6%B3%A8%E5%86%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96%E5%8C%85">从其它注册服务引入依赖包</a></h3>
<p>为了使用 <code>crates.io</code> 之外的注册服务，我们需要对 <code>$HOME/.cargo/config.toml</code> ($CARGO_HOME 下) 文件进行配置，添加新的服务提供商，有两种方式可以实现。</p>
<blockquote>
<p>由于国内访问国外注册服务的不稳定性，我们可以使用<a href="https://mirrors.ustc.edu.cn/help/crates.io-index.html">科大的注册服务</a>来提升下载速度，以下注册服务的链接都是科大的</p>
</blockquote>
<p><strong>首先是在 <code>crates.io</code> 之外添加新的注册服务</strong> ，修改 <code>.cargo/config.toml</code> 添加以下内容：</p>
<pre><code class="language-toml">[registries]
ustc = { index = &quot;https://mirrors.ustc.edu.cn/crates.io-index/&quot; }
</code></pre>
<p>对于这种方式，我们的项目的 <code>Cargo.toml</code> 中的依赖包引入方式也有所不同：</p>
<pre><code class="language-toml">[dependencies]
time = {  registry = &quot;ustc&quot; }
</code></pre>
<p>在重新配置后，初次构建可能要较久的时间，因为要下载更新 <code>ustc</code> 注册服务的索引文件，还挺大的...</p>
<p>注意，这一种使用方式最大的缺点就是在引用依赖包时要指定注册服务: <code>time = { registry = "ustc" }</code>。</p>
<p><strong>而第二种方式就不需要，因为它是直接使用新注册服务来替代默认的 <code>crates.io</code></strong> 。</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'ustc'

[source.ustc]
registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;
</code></pre>
<p>上面配置中的第一个部分，首先将源 <code>source.crates-io</code> 替换为 <code>ustc</code>，然后在第二部分指定了 <code>ustc</code> 源的地址。</p>
<blockquote>
<p>注意，如果你要发布包到 <code>crates.io</code> 上，那该包的依赖也必须在 <code>crates.io</code> 上</p>
</blockquote>
<h4 id="git"><a href="https://course.rs/cargo/reference/specify-deps.html#%E5%BC%95%E5%85%A5-git-%E4%BB%93%E5%BA%93%E4%BD%9C%E4%B8%BA%E4%BE%9D%E8%B5%96%E5%8C%85">引入 git 仓库作为依赖包</a></h4>
<p>若要引入 git 仓库中的库作为依赖包，你至少需要提供一个仓库的地址:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex&quot; }
</code></pre>
<p>由于没有指定版本，Cargo 会假定我们使用 <code>master</code> 或 <code>main</code> 分支的最新 <code>commit</code> 。你可以使用 <code>rev</code>、<code>tag</code> 或 <code>branch</code> 来指定想要拉取的版本。例如下面代码拉取了 <code>next</code> 分支上的最新 <code>commit</code>：</p>
<pre><code class="language-toml">[dependencies]
regex = { git = &quot;https://github.com/rust-lang/regex&quot;, branch = &quot;next&quot; }
</code></pre>
<p>任何非 <code>tag</code> 和 <code>branch</code> 的类型都可以通过 <code>rev</code> 来引入，例如通过最近一次 <code>commit</code> 的哈希值引入: <code>rev = "4c59b707"</code>，再比如远程仓库提供的的具名引用: <code>rev = "refs/pull/493/head"</code>。</p>
<p>一旦 <code>git</code> 依赖被拉取下来，该版本就会被记录到 <code>Cargo.lock</code> 中进行锁定。因此 <code>git</code> 仓库中后续新的提交不再会被自动拉取，除非你通过 <code>cargo update</code> 来升级。需要注意的是锁定一旦被删除，那 Cargo 依然会按照 <code>Cargo.toml</code> 中配置的地址和版本去拉取新的版本，如果你配置的版本不正确，那可能会拉取下来一个不兼容的新版本！</p>
<p><strong>因此不要依赖锁定来完成版本的控制，而应该老老实实的在 <code>Cargo.toml</code> 小心配置你希望使用的版本。</strong></p>
<p>如果访问的是私有仓库，你可能需要授权来访问该仓库，可以查看<a href="https://course.rs/cargo/git-auth.html">这里</a>了解授权的方式。</p>
<h4 id="_6"><a href="https://course.rs/cargo/reference/specify-deps.html#%E9%80%9A%E8%BF%87%E8%B7%AF%E5%BE%84%E5%BC%95%E5%85%A5%E6%9C%AC%E5%9C%B0%E4%BE%9D%E8%B5%96%E5%8C%85">通过路径引入本地依赖包</a></h4>
<p>Cargo 支持通过路径的方式来引入本地的依赖包：一般来说，本地依赖包都是同一个项目内的内部包，例如假设我们有一个 <code>hello_world</code> 项目( package )，现在在其根目录下新建一个包:</p>
<pre><code class="language-shell">#  在 hello_world/ 目录下
$ cargo new hello_utils
</code></pre>
<p>新建的 <code>hello_utils</code> 文件夹跟 <code>src</code>、<code>Cargo.toml</code> 同级，现在修改 <code>Cargo.toml</code> 让 <code>hello_world</code> 项目引入新建的包:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot; }
# 以下路径也可以
# hello_utils = { path = &quot;./hello_utils&quot; }
# hello_utils = { path = &quot;../hello_world/hello_utils&quot; }
</code></pre>
<p>但是，此时的 <code>hello_world</code> 是无法发布到 <code>crates.io</code> 上的。想要发布，需要先将 <code>hello_utils</code> 先发布到 <code>crates.io</code> 上，然后再通过 <code>crates.io</code> 的方式来引入:</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = &quot;hello_utils&quot;, version = &quot;0.1.0&quot; }
</code></pre>
<blockquote>
<p>注意！使用 <code>path</code> 指定依赖的 package 将无法发布到 <code>crates.io</code>，除非 <code>path</code> 存在于 <a href="https://course.rs/cargo/reference/specify-deps.html#dev-dependencies">[dev-dependencies]</a> 中。当然，你还可以使用多种引用混合的方式来解决这个问题，下面将进行介绍</p>
</blockquote>
<h4 id="_7"><a href="https://course.rs/cargo/reference/specify-deps.html#%E5%A4%9A%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E6%B7%B7%E5%90%88">多引用方式混合</a></h4>
<p>实际上，我们可以同时使用多种方式来引入同一个包，例如本地引入和 <code>crates.io</code> :</p>
<pre><code class="language-toml">[dependencies]
# 本地使用时，通过 path 引入,
# 发布到 `crates.io` 时，通过 `crates.io` 的方式引入：  version = &quot;1.0&quot;
bitflags = { path = &quot;my-bitflags&quot;, version = &quot;1.0&quot; }

# 本地使用时，通过 git 仓库引入
# 当发布时，通过 `crates.io` 引入： version = &quot;1.0&quot;
smallvec = { git = &quot;https://github.com/servo/rust-smallvec&quot;, version = &quot;1.0&quot; }

# N.B. 若 version 无法匹配，Cargo 将无法编译
</code></pre>
<p>这种方式跟下章节将要讲述的依赖覆盖类似，但是前者只会应用到当前声明的依赖包上。</p>
<h4 id="_8"><a href="https://course.rs/cargo/reference/specify-deps.html#%E6%A0%B9%E6%8D%AE%E5%B9%B3%E5%8F%B0%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96">根据平台引入依赖</a></h4>
<p>我们还可以根据特定的平台来引入依赖:</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = &quot;0.4.0&quot;

[target.'cfg(unix)'.dependencies]
openssl = &quot;1.0.1&quot;

[target.'cfg(target_arch = &quot;x86&quot;)'.dependencies]
native = { path = &quot;native/i686&quot; }

[target.'cfg(target_arch = &quot;x86_64&quot;)'.dependencies]
native = { path = &quot;native/x86_64&quot; }
</code></pre>
<p>此处的语法跟 Rust 的 <a href="https://doc.rust-lang.org/stable/reference/conditional-compilation.html"><code>#[cfg]</code></a> 语法非常相像，因此我们还能使用逻辑操作符进行控制:</p>
<pre><code class="language-toml">[target.'cfg(not(unix))'.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<p>这里的意思是，当不是 <code>unix</code> 操作系统时，才对 <code>openssl</code> 进行引入。</p>
<p>如果你想要知道 <code>cfg</code> 能够作用的目标，可以在终端中运行 <code>rustc --print=cfg</code> 进行查询。当然，你可以指定平台查询: <code>rustc --print=cfg --target=x86_64-pc-windows-msvc</code>，该命令将对 <code>64bit</code> 的 Windows 进行查询。</p>
<p>聪明的同学已经发现，这非常类似于条件依赖引入，那我们是不是可以根据自定义的条件来决定是否引入某个依赖呢？具体答案参见后续的 <a href="https://course.rs/cargo/reference/features.html">feature</a> 章节。这里是一个简单的示例:</p>
<pre><code class="language-toml">[dependencies]
foo = { version = &quot;1.0&quot;, optional = true }
bar = { version = &quot;1.0&quot;, optional = true }

[features]
fancy-feature = [&quot;foo&quot;, &quot;bar&quot;]
</code></pre>
<p>但是需要注意的是，你如果妄图通过 <code>cfg(feature)</code>、<code>cfg(debug_assertions)</code>, <code>cfg(test)</code> 和 <code>cfg(proc_macro)</code> 的方式来条件引入依赖，那是不可行的。</p>
<p><code>Cargo</code> 还允许通过下面的方式来引入平台特定的依赖:</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = &quot;0.4.0&quot;

[target.i686-unknown-linux-gnu.dependencies]
openssl = &quot;1.0.1&quot;
</code></pre>
<h4 id="target"><a href="https://course.rs/cargo/reference/specify-deps.html#%E8%87%AA%E5%AE%9A%E4%B9%89-target-%E5%BC%95%E5%85%A5">自定义 target 引入</a></h4>
<p>如果你在使用自定义的 <code>target</code> ：例如 <code>--target bar.json</code>，那么可以通过下面方式来引入依赖:</p>
<pre><code class="language-toml">[target.bar.dependencies]
winhttp = &quot;0.4.0&quot;

[target.my-special-i686-platform.dependencies]
openssl = &quot;1.0.1&quot;
native = { path = &quot;native/i686&quot; }
</code></pre>
<blockquote>
<p>需要注意，这种使用方式在 <code>stable</code> 版本的 Rust 中无法被使用，建议大家如果没有特别的需求，还是使用之前提到的 feature 方式</p>
</blockquote>
<h4 id="dev-dependencies"><a href="https://course.rs/cargo/reference/specify-deps.html#dev-dependencies">[dev-dependencies]</a></h4>
<p>你还可以为项目添加只在测试时需要的依赖库，类似于 <code>package.json</code>( Nodejs )文件中的 <code>devDependencies</code>，可以在 <code>Cargo.toml</code> 中添加 <code>[dev-dependencies]</code> 来实现:</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = &quot;0.3&quot;
</code></pre>
<p>这里的依赖只会在运行测试、示例和 benchmark 时才会被引入。并且，假设 <code>A</code> 包引用了 <code>B</code>，而 <code>B</code> 通过 <code>[dev-dependencies]</code> 的方式引用了 <code>C</code> 包， 那 <code>A</code> 是不会引用 <code>C</code> 包的。</p>
<p>当然，我们还可以指定平台特定的测试依赖包:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = &quot;0.0.1&quot;
</code></pre>
<blockquote>
<p>注意，当发布包到 crates.io 时，<code>[dev-dependencies]</code> 中的依赖只有指定了 <code>version</code> 的才会被包含在发布包中。况且，再加上测试稳定性的考虑，我们建议为 <code>[dev-dependencies]</code> 中的包指定相应的版本号</p>
</blockquote>
<h4 id="build-dependencies"><a href="https://course.rs/cargo/reference/specify-deps.html#build-dependencies">[build-dependencies]</a></h4>
<p>我们还可以指定某些依赖仅用于构建脚本:</p>
<pre><code class="language-toml">[build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>当然，平台特定的依然可以使用：</p>
<pre><code class="language-toml">[target.'cfg(unix)'.build-dependencies]
cc = &quot;1.0.3&quot;
</code></pre>
<p>有一点需要注意：构建脚本(<code>&lt;span&gt; &lt;/span&gt;build.rs</code> )和项目的正常代码是彼此独立，因此它们的依赖不能互通： 构建脚本无法使用 <code>[dependencies]</code> 或 <code>[dev-dependencies]</code> 中的依赖，而 <code>[build-dependencies]</code> 中的依赖也无法被构建脚本之外的代码所使用。</p>
<h4 id="features"><a href="https://course.rs/cargo/reference/specify-deps.html#%E9%80%89%E6%8B%A9-features">选择 features</a></h4>
<p>如果你依赖的包提供了条件性的 <code>features</code>，你可以指定使用哪一个:</p>
<pre><code class="language-toml">[dependencies.awesome]
version = &quot;1.3.5&quot;
default-features = false # 不要包含默认的 features，而是通过下面的方式来指定
features = [&quot;secure-password&quot;, &quot;civet&quot;]
</code></pre>
<p>更多的信息参见 <a href="https://course.rs/cargo/reference/features.html">Features 章节</a></p>
<h3 id="cargotoml"><a href="https://course.rs/cargo/reference/specify-deps.html#%E5%9C%A8-cargotoml-%E4%B8%AD%E9%87%8D%E5%91%BD%E5%90%8D%E4%BE%9D%E8%B5%96">在 Cargo.toml 中重命名依赖</a></h3>
<p>如果你想要实现以下目标：</p>
<ul>
<li>避免在 Rust 代码中使用 <code>use foo as bar</code></li>
<li>依赖某个包的多个版本</li>
<li>依赖来自于不同注册服务的同名包</li>
</ul>
<p>那可以使用 Cargo 提供的 <code>package key</code> :</p>
<pre><code class="language-toml">[package]
name = &quot;mypackage&quot;
version = &quot;0.0.1&quot;

[dependencies]
foo = &quot;0.1&quot;
bar = { git = &quot;https://github.com/example/project&quot;, package = &quot;foo&quot; }
baz = { version = &quot;0.1&quot;, registry = &quot;custom&quot;, package = &quot;foo&quot; }
</code></pre>
<p>此时，你的代码中可以使用三个包：</p>
<pre><code class="language-toml">extern crate foo; // 来自 crates.io
extern crate bar; // 来自 git repository
extern crate baz; // 来自 registry `custom`
</code></pre>
<p>有趣的是，由于这三个 <code>package</code> 的名称都是 <code>foo</code>(在各自的 <code>Cargo.toml</code> 中定义)，因此我们显式的通过 <code>package = "foo"</code> 的方式告诉 Cargo：我们需要的就是这个 <code>foo package</code>，虽然它被重命名为 <code>bar</code> 或 <code>baz</code>。</p>
<p>有一点需要注意，当使用可选依赖时，如果你将 <code>foo</code> 包重命名为 <code>bar</code> 包，那引用前者的 feature 时的路径名也要做相应的修改:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = &quot;0.1&quot;, package = 'foo', optional = true }

[features]
log-debug = ['bar/log-debug'] # 若使用 'foo/log-debug' 会导致报错
</code></pre>
<h2 id="-rustrust-course">参考：<a href="https://course.rs/cargo/reference/specify-deps.html">指定依赖项 - Rust语言圣经(Rust Course)</a></h2>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../std-ops/" class="btn btn-neutral float-right" title="ops 模块">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../Trait/" class="btn btn-neutral" title="Trait"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
      <p>Copyright © 2021 <a href="https://zsf90.github.io" target="_blank" title="zsf90">信念D力量</a></p>
    
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../Trait/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../std-ops/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(false);
        };
    </script>

</body>
</html>
